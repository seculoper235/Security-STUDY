*** 적용 방법 ***
OAuth는 크게 나눠보자면

Authorization Code를 발급받는 단계,
Access Token으로 교환하는 단계,
Token으로 API를 요청하는 단계, 3가지로 나뉘어지며,

이 단계를 클라이언트와 서버가 각각 어떻게 분담하느냐에 따라 4가지로 나뉜다.



** 클라이언트: Auth Code -> Access Token -> API 요청
- 라이브러리 이용
   장점)
      딱히 없는 것 같다.
   단점)
      전부다. 클라이언트에 OAuth 로직을 다 때려박는건 좀 아니지 싶다...
********************************************************************************************************


** 클라이언트: Auth Code -> Access Token
    서버: API 요청
- 클)
     /o/oauth2/auth로 데이터를 보냄 -> redirect Url로 Auth Code를 받아옴
     -> /o/oauth2/token으로 Auth Code와 Secret Key를 같이 보냄 -> Access Token을 받아옴
  서버)
     알아서 Resource Server로 요청을 보냄

  장점)
     클라이언트나 서버나 구분이 명확해져 구현하기가 쉽다
  단점)
     클라이언트가 Secret Key를 가지고 있게된다
********************************************************************************************************


** 클라이언트: Auth Code
    서버: Access Token -> API 요청
- 클)
     /o/oauth2/auth로 데이터를 보냄 -> redirect Url로 Auth Code를 받아옴
   서버)
      RestTemplate로 Auth Code를 받아서 Access Token을 반환하는 메소드 작성
      -> 다시 RestTemplate로 Access Token를 가지고 API를 요청하는 메소드 작성

   장점)
      서버가 Secret Key를 가지고 있게 된다
   단점)
      RestTemplate을 두번이나 사용하여 요청을 보내야 한다
      Auth Code를 Access Token으로 변환하는 SpringBoot 기능을 사용할 수 없다
      (왜냐면 Spring에서 자체적으로 Request를 작성하고 요청을 보내기 때문에, 간섭할 수 없다)
********************************************************************************************************


** 서버: Auth Code -> Access Token -> API 요청
- SpringBoot Security 이용
   장점)
      서버가 다 하기에 SpringBoot를 사용하여 매우 간편하고 안전하게 처리 가능하다
   단점)
      클라이언트를 별도로 둘 수 없다. 즉, 올인원 애플리케이션만 가능하다
      logPage()나 login/logoutSuccessUrl() 등을 모두 서버의 입장에서 작동한다
      (즉, 클라이언트의 8080 포트에서는 작동하지 않는다는 이야기)
********************************************************************************************************